from fastapi import FastAPI, HTTPException, File, Form, Depends, Query, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import Response, JSONResponse
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any, Union
import os
import httpx
import time
import json
import uuid
from dotenv import load_dotenv
from app.models import (
    get_model_categories, 
    get_models_by_category, 
    get_model_details,
    fetch_openrouter_models,
    get_available_model_ids,
    refresh_models,
    DEFAULT_MODEL
)
from app.utils import DocumentProcessor, DocumentStore

# Load environment variables
load_dotenv()

app = FastAPI(title="AI Chatbot Profiles API", 
              description="Backend API for managing AI chatbot profiles and interactions",
              version="1.0.0")

# Add CORS middleware to allow requests from the frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allows all origins
    allow_credentials=True,
    allow_methods=["*"],  # Allows all methods
    allow_headers=["*"],  # Allows all headers
)

# Models
class Message(BaseModel):
    role: str
    content: str

class ChatRequest(BaseModel):
    messages: List[Message]
    max_tokens: Optional[int] = 500
    temperature: Optional[float] = 0.7
    user_id: Optional[str] = "anonymous"
    model: Optional[str] = None
    use_document_context: Optional[bool] = False
    session_id: Optional[str] = None

class ChatResponse(BaseModel):
    message: Message
    usage: Optional[dict] = None
    response_time: Optional[float] = None
    model_used: Optional[str] = None
    token_count: Optional[int] = None

class DocumentInfo(BaseModel):
    id: str
    filename: str
    timestamp: int
    chunk_count: int

class ModelComparison(BaseModel):
    model_a: str
    model_b: str
    query: str
    result_a: Dict[str, Any]
    result_b: Dict[str, Any]
    metrics: Dict[str, Any]

# Initialize document processor and store
document_processor = DocumentProcessor()
document_store = DocumentStore()

# OpenRouter API configuration
OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY", "")
OPENROUTER_URL = "https://openrouter.ai/api/v1/chat/completions"

# Session metrics storage
session_metrics = {}

# Profile schemas
class CreateProfileRequest(BaseModel):
    name: str
    description: str
    model: str
    temperature: float = Field(default=0.7, ge=0, le=2.0)

class ChatbotProfile(BaseModel):
    id: str
    name: str
    description: str
    model: str
    temperature: float
    created_at: str
    updated_at: Optional[str] = None
    training_data_count: Optional[int] = 0

class ApiKeyResponse(BaseModel):
    profile_id: str
    api_key: str

# Simulated profiles storage (in production this would be a database)
profiles_db = {}
profile_api_keys = {}

# Training data models
class TrainingDataResponse(BaseModel):
    id: str
    profile_id: str
    filename: str
    uploaded_at: str
    size: int
    status: str = "processed"  # 'processing', 'processed', 'failed'

# Storage for training data (in production this would be a database)
training_data_db = {}

@app.get("/")
def read_root():
    """Base endpoint that returns a welcome message."""
    return {"message": "Welcome to the AI Chatbot Profiles API"}

# Model endpoints
@app.get("/api/models", response_model=Dict[str, Dict[str, Any]])
async def get_models():
    """Get all available models."""
    return fetch_openrouter_models()

@app.get("/api/models/categories", response_model=List[str])
async def get_categories():
    """Get all model categories."""
    return get_model_categories()

@app.get("/api/models/category/{category}", response_model=Dict[str, Dict[str, Any]])
async def get_models_in_category(category: str):
    """Get models in a specific category."""
    return get_models_by_category(category)

@app.get("/api/models/{model_id}", response_model=Dict[str, Any])
async def get_model(model_id: str):
    """Get details for a specific model."""
    try:
        return get_model_details(model_id)
    except KeyError:
        raise HTTPException(status_code=404, detail=f"Model {model_id} not found")

@app.get("/api/models/refresh", response_model=Dict[str, Dict[str, Any]])
async def refresh_model_data():
    """Refresh model data from OpenRouter."""
    return refresh_models()

def _prepare_document_context(chunks: List[str], max_chunks: int = 5) -> str:
    """Prepare document context from chunks
    
    Args:
        chunks: List of document chunks
        max_chunks: Maximum number of chunks to include
        
    Returns:
        Formatted document context string
    """
    if not chunks:
        return ""
    
    # If we have fewer chunks than max_chunks, use all of them
    if len(chunks) <= max_chunks:
        formatted_chunks = chunks
    else:
        # Otherwise, take a selection of chunks
        # We take the first chunk to provide an introduction
        # and then a sampling of the remaining chunks
        step = (len(chunks) - 1) // (max_chunks - 1)
        indices = [0] + [i for i in range(1, len(chunks), step)][:max_chunks-1]
        formatted_chunks = [chunks[i] for i in indices]
    
    # Format chunks with numbering and delimiter
    formatted_text = ""
    for i, chunk in enumerate(formatted_chunks):
        formatted_text += f"Document Section {i+1}:\n{chunk}\n\n---\n\n"
    
    return formatted_text

@app.post("/api/chat", response_model=ChatResponse)
async def chat(request: ChatRequest, background_tasks: BackgroundTasks):
    """
    Send a chat request to the OpenRouter API and return the response.
    """
    start_time = time.time()
    
    # Check if API key is set
    if not OPENROUTER_API_KEY:
        raise HTTPException(status_code=500, detail="OpenRouter API key not configured")
    
    # Use the specified model or fall back to the default
    model = request.model if hasattr(request, 'model') and request.model else DEFAULT_MODEL
    
    # Get document context if requested
    system_message = None
    if request.use_document_context:
        chunks = document_store.get_all_document_chunks()
        if chunks:
            context = _prepare_document_context(chunks)
            system_message = {
                "role": "system", 
                "content": (
                    "You are an assistant with access to the following document sections. "
                    "Answer the user's questions based only on the information provided in these documents. "
                    "If the information needed to answer is not in the documents, state clearly that you "
                    "don't have that information in the provided documents rather than making up an answer.\n\n"
                    "When referencing information, mention which document section it came from.\n\n"
                    f"Here are the document sections:\n\n{context}"
                )
            }
        else:
            # Even if use_document_context is true but no documents are available,
            # add a system message to inform the user
            system_message = {
                "role": "system",
                "content": (
                    "You are a helpful assistant. Note that the system is configured to use document "
                    "context, but no documents have been uploaded yet. You can only answer based on "
                    "your general knowledge until documents are provided."
                )
            }
    
    # Prepare messages with system message if available
    messages = []
    if system_message:
        messages.append(system_message)
    messages.extend([{"role": msg.role, "content": msg.content} for msg in request.messages])
    
    # Prepare the request payload
    payload = {
        "model": model,
        "messages": messages,
        "max_tokens": request.max_tokens,
        "temperature": request.temperature,
        "user": request.user_id
    }
    
    headers = {
        "Authorization": f"Bearer {OPENROUTER_API_KEY}",
        "Content-Type": "application/json",
        "HTTP-Referer": "https://school-management-assistant.com"  # Replace with your actual domain
    }
    
    try:
        # Make the request to OpenRouter
        async with httpx.AsyncClient() as client:
            response = await client.post(
                OPENROUTER_URL,
                json=payload,
                headers=headers,
                timeout=30.0
            )
            
            # Check if the request was successful
            response.raise_for_status()
            response_data = response.json()
            
            # Extract the response message
            if "choices" in response_data and len(response_data["choices"]) > 0:
                message_data = response_data["choices"][0]["message"]
                message = Message(role=message_data["role"], content=message_data["content"])
                
                # Calculate response time
                response_time = time.time() - start_time
                
                # Get token usage
                token_count = response_data.get("usage", {}).get("total_tokens", 0)
                
                # Store metrics for this session if session_id is provided
                if request.session_id:
                    if request.session_id not in session_metrics:
                        session_metrics[request.session_id] = []
                    
                    session_metrics[request.session_id].append({
                        "timestamp": time.time(),
                        "model": model,
                        "response_time": response_time,
                        "tokens": token_count,
                        "request_size": len(str(request.messages)),
                        "response_size": len(message.content)
                    })
                
                # Return the response
                return ChatResponse(
                    message=message,
                    usage=response_data.get("usage"),
                    response_time=response_time,
                    model_used=model,
                    token_count=token_count
                )
            else:
                raise HTTPException(status_code=500, detail="Invalid response from language model")
                
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except httpx.RequestError as e:
        raise HTTPException(status_code=500, detail=f"Request error: {str(e)}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Unexpected error: {str(e)}")

# A/B Testing endpoint
@app.post("/api/compare_models", response_model=ModelComparison)
async def compare_models(
    model_a: str = Query(..., description="First model to compare"),
    model_b: str = Query(..., description="Second model to compare"),
    messages: List[Dict[str, str]] = None,
):
    """
    Compare responses from two different models for the same input
    """
    # Validate models exist
    models = fetch_openrouter_models()
    if model_a not in models:
        raise HTTPException(status_code=404, detail=f"Model {model_a} not found")
    if model_b not in models:
        raise HTTPException(status_code=404, detail=f"Model {model_b} not found")
    
    # Convert messages to Chat format
    chat_messages = [Message(**msg) for msg in messages]
    
    # Create requests for both models
    request_a = ChatRequest(
        messages=chat_messages,
        model=model_a,
        session_id="model_comparison"
    )
    
    request_b = ChatRequest(
        messages=chat_messages,
        model=model_b,
        session_id="model_comparison"
    )
    
    try:
        # Get responses from both models
        response_a = await chat(request_a, BackgroundTasks())
        response_b = await chat(request_b, BackgroundTasks())
        
        # Check if responses have content
        if not response_a.message.content.strip():
            print(f"Warning: Empty response from model {model_a}")
        if not response_b.message.content.strip():
            print(f"Warning: Empty response from model {model_b}")
        
        # Calculate comparison metrics
        # - Response time difference
        # - Token count difference
        # - Response length difference
        metrics = {
            "response_time_diff": response_b.response_time - response_a.response_time,
            "token_count_diff": response_b.token_count - response_a.token_count,
            "response_length_diff": len(response_b.message.content) - len(response_a.message.content),
        }
        
        # Return comparison results
        return ModelComparison(
            model_a=model_a,
            model_b=model_b,
            query=chat_messages[-1].content if chat_messages else "",
            result_a={
                "content": response_a.message.content,
                "response_time": response_a.response_time,
                "token_count": response_a.token_count
            },
            result_b={
                "content": response_b.message.content,
                "response_time": response_b.response_time,
                "token_count": response_b.token_count
            },
            metrics=metrics
        )
    except Exception as e:
        raise HTTPException(
            status_code=500, 
            detail=f"Error comparing models: {str(e)}"
        )

# Document management endpoints
@app.post("/api/upload", response_model=Dict[str, str])
async def upload_file(file: bytes = File(...), filename: str = Form(...)):
    """
    Handle file uploads for knowledge augmentation
    """
    try:
        # Process the document
        chunks = document_processor.process_document(file, filename)
        
        # Store document chunks
        doc_id = document_store.add_document(filename, chunks)
            
        return {
            "message": f"File {filename} uploaded and processed successfully",
            "document_id": doc_id,
            "chunk_count": str(len(chunks))
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"File processing failed: {str(e)}")

@app.get("/api/documents", response_model=List[DocumentInfo])
async def get_documents():
    """Get all uploaded documents"""
    return document_store.get_document_metadata()

@app.delete("/api/documents/{doc_id}")
async def delete_document(doc_id: str):
    """Delete a document"""
    success = document_store.remove_document(doc_id)
    if not success:
        raise HTTPException(status_code=404, detail=f"Document {doc_id} not found")
    return {"message": f"Document {doc_id} deleted successfully"}

@app.get("/api/documents/{doc_id}", response_model=Dict[str, Any])
async def get_document_details(doc_id: str):
    """Get details for a specific document including chunks"""
    # Get metadata for the document
    metadata_list = document_store.get_document_metadata()
    
    # Find the document in the metadata
    doc_metadata = None
    for doc in metadata_list:
        if doc["id"] == doc_id:
            doc_metadata = doc
            break
    
    if not doc_metadata:
        raise HTTPException(status_code=404, detail=f"Document {doc_id} not found")
    
    # Get chunks for the document
    chunks = document_store.get_document_chunks(doc_id)
    
    # Calculate document size (approximate)
    total_size = sum(len(chunk) for chunk in chunks)
    
    # Return document details
    return {
        "id": doc_metadata["id"],
        "filename": doc_metadata["filename"],
        "timestamp": doc_metadata["timestamp"],
        "chunk_count": doc_metadata["chunk_count"],
        "size": total_size,
        "chunks": chunks
    }

# Performance metrics endpoint
@app.get("/api/metrics", response_model=Dict[str, Any])
async def get_metrics(session_id: Optional[str] = None):
    """Get performance metrics"""
    if session_id and session_id in session_metrics:
        return {"metrics": session_metrics[session_id]}
    elif not session_id:
        # Return all metrics
        return {"metrics": session_metrics}
    else:
        return {"metrics": []}

# Add a health check endpoint
@app.get("/health")
def health_check():
    return {"status": "ok"}

@app.get("/favicon.ico", include_in_schema=False)
async def favicon():
    """Handle favicon.ico requests to prevent 404 errors."""
    return Response(content="", media_type="image/x-icon")

# Profiles endpoints
@app.get("/api/profiles", response_model=List[ChatbotProfile])
async def get_profiles():
    """Get all chatbot profiles"""
    return list(profiles_db.values())

@app.get("/api/profiles/{profile_id}", response_model=ChatbotProfile)
async def get_profile(profile_id: str):
    """Get a specific chatbot profile by ID"""
    if profile_id not in profiles_db:
        raise HTTPException(status_code=404, detail="Profile not found")
    return profiles_db[profile_id]

@app.post("/api/profiles", response_model=ChatbotProfile)
async def create_profile(profile: CreateProfileRequest):
    """Create a new chatbot profile"""
    profile_id = str(uuid.uuid4())
    timestamp = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
    
    new_profile = ChatbotProfile(
        id=profile_id,
        name=profile.name,
        description=profile.description,
        model=profile.model,
        temperature=profile.temperature,
        created_at=timestamp
    )
    
    profiles_db[profile_id] = new_profile
    return new_profile

@app.put("/api/profiles/{profile_id}", response_model=ChatbotProfile)
async def update_profile(profile_id: str, profile_update: CreateProfileRequest):
    """Update an existing chatbot profile"""
    if profile_id not in profiles_db:
        raise HTTPException(status_code=404, detail="Profile not found")
    
    existing_profile = profiles_db[profile_id]
    timestamp = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
    
    updated_profile = ChatbotProfile(
        id=profile_id,
        name=profile_update.name,
        description=profile_update.description,
        model=profile_update.model,
        temperature=profile_update.temperature,
        created_at=existing_profile.created_at,
        updated_at=timestamp,
        training_data_count=existing_profile.training_data_count
    )
    
    profiles_db[profile_id] = updated_profile
    return updated_profile

@app.delete("/api/profiles/{profile_id}")
async def delete_profile(profile_id: str):
    """Delete a chatbot profile"""
    if profile_id not in profiles_db:
        raise HTTPException(status_code=404, detail="Profile not found")
    
    # Delete the profile
    del profiles_db[profile_id]
    
    # Delete associated API key if it exists
    if profile_id in profile_api_keys:
        del profile_api_keys[profile_id]
    
    return {"message": "Profile deleted successfully"}

@app.post("/api/profiles/{profile_id}/api-key", response_model=ApiKeyResponse)
async def generate_api_key(profile_id: str):
    """Generate an API key for a profile"""
    if profile_id not in profiles_db:
        raise HTTPException(status_code=404, detail="Profile not found")
    
    # Generate a new API key
    api_key = f"sk-{uuid.uuid4().hex}"
    
    # Store the API key
    profile_api_keys[profile_id] = api_key
    
    return ApiKeyResponse(profile_id=profile_id, api_key=api_key)

@app.delete("/api/profiles/{profile_id}/api-key")
async def revoke_api_key(profile_id: str):
    """Revoke an API key for a profile"""
    if profile_id not in profiles_db:
        raise HTTPException(status_code=404, detail="Profile not found")
    
    if profile_id not in profile_api_keys:
        raise HTTPException(status_code=404, detail="No API key found for this profile")
    
    # Delete the API key
    del profile_api_keys[profile_id]
    
    return {"message": "API key revoked successfully"}

@app.post("/api/profiles/{profile_id}/test")
async def test_chatbot(profile_id: str, message: Dict[str, str]):
    """Test a chatbot profile with a message"""
    if profile_id not in profiles_db:
        raise HTTPException(status_code=404, detail="Profile not found")
    
    profile = profiles_db[profile_id]
    
    # Create a chat request using the profile settings
    chat_request = ChatRequest(
        messages=[Message(role="user", content=message.get("message", "Hello"))],
        model=profile.model,
        temperature=profile.temperature
    )
    
    # Process the chat request
    response = await chat(chat_request, BackgroundTasks())
    
    return {"response": response.message.content}

# File upload endpoints for training data
@app.post("/api/profiles/{profile_id}/training-data", response_model=TrainingDataResponse)
async def upload_training_data(profile_id: str, file: bytes = File(...), filename: str = Form(...)):
    """Upload training data for a specific profile"""
    if profile_id not in profiles_db:
        raise HTTPException(status_code=404, detail="Profile not found")
    
    # Validate file extension
    valid_extensions = ['.txt', '.pdf', '.docx', '.csv']
    file_ext = os.path.splitext(filename)[1].lower()
    if file_ext not in valid_extensions:
        raise HTTPException(
            status_code=400, 
            detail=f"Unsupported file format. Please upload one of: {', '.join(valid_extensions)}"
        )
    
    # Process file
    data_id = str(uuid.uuid4())
    timestamp = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
    file_size = len(file)
    
    # Store training data
    training_data = TrainingDataResponse(
        id=data_id,
        profile_id=profile_id,
        filename=filename,
        uploaded_at=timestamp,
        size=file_size,
        status="processed"
    )
    
    # Update profile's training data count
    if profile_id not in training_data_db:
        training_data_db[profile_id] = {}
    
    training_data_db[profile_id][data_id] = training_data
    
    # Update profile's training data count
    profile = profiles_db[profile_id]
    profile.training_data_count = len(training_data_db[profile_id])
    
    return training_data

@app.get("/api/profiles/{profile_id}/training-data", response_model=List[TrainingDataResponse])
async def get_training_data(profile_id: str):
    """Get all training data for a specific profile"""
    if profile_id not in profiles_db:
        raise HTTPException(status_code=404, detail="Profile not found")
    
    if profile_id not in training_data_db:
        return []
    
    return list(training_data_db[profile_id].values())

@app.delete("/api/profiles/{profile_id}/training-data/{data_id}")
async def delete_training_data(profile_id: str, data_id: str):
    """Delete training data for a specific profile"""
    if profile_id not in profiles_db:
        raise HTTPException(status_code=404, detail="Profile not found")
    
    if profile_id not in training_data_db or data_id not in training_data_db[profile_id]:
        raise HTTPException(status_code=404, detail="Training data not found")
    
    # Delete training data
    del training_data_db[profile_id][data_id]
    
    # Update profile's training data count
    profile = profiles_db[profile_id]
    profile.training_data_count = len(training_data_db[profile_id])
    
    return {"message": "Training data deleted successfully"} 